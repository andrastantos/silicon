TODO:
+ Kill symbol table? - no: still needed to detect name collision between ports/wires/sub-modules
+ Review inner/outer aliases, primary names etc. for ports
+ what is Module.name_lookup? - don't know: deleted
- XNet.names is needed at all?
- Clear netlist reference from Module
+ Deal with Port.rhs_name -> probably need something along the lines that's in Module._generate() now, except moved to the port.
+ inner_aliases: needed until xnet name population happens. attribute is deleted afterwards
+ inner_auto_name
- has_explicit_name on Port/Wire
+ outer_aliases: needed until xnet name population happens. attribute is deleted afterwards
+ outer_auto_name
+ interface_name: new name on Ports (though it leaks into wires unfortunately) to denote the name on the Module interface
+ Module.has_user_assigned_name -> renamed to has_explicit_name
+ get_inline_block should use get_lhs_name for statements and add_rhs_expression for expressions. -> done differently, but done

------------------
- better error messages
+ fix __getitem__ in a LHS context
+ Empty the Module namespace as much as possible
+ Finish @module decorators
+ @module should use signature names for inputs
- clean up Tracer and its name creation (maybe default to no_trace?)
+ We should not attempt to propagate types early. There's a place for that in elaborate, so we shouldn't try to be smart about it in ex. __getitem__

------------------
+ Enum port types - this needs the re-introduction of types that generate RTL as interfaces and structs used to be able to.
+ Need type-conversion, most importantly from Number to Enum
+ PortType --> NetType
+ PortBase --> Junction
+ Wire --> not based on Port, but Junction

-------------------
- RAMs and ROMs
- Alternative generation of Select* statements (inline statements instead of expressions)
+ FSM: use const_convert_lookup (or similar) to find undelying type of state constants
+ FSM: use underlying state type to come up with final state type. Use get_common_net_type and PortType.result_type(operation="SELECT") to achieve this.
+ FSM: Junction has a has_driver member. Maybe a similar (get_driver) thingy could be created and used to generate the drawing.
- FIFOs
- CDCs
+ The above probably needs interfaces, so interfaces
- Replace yield with async?
- Register generator, as in configuration registers attached to a bus.
- Somhow fix mixed acceses. Such as out_a = in_a.a.b[9:4][0].c.d and of course the reverse as well.

-------------------
- Think of a better name
- Re-use silicon as the SKiDL (https://xess.com/skidl/docs/_site/) variant of the idea, one that's used for SCH replacement

-------------------
- Somehow publish Jupyter notebooks
- Add DarwIO (https://github.com/QuantStack/jupyterlab-drawio) to Jupyter
- Add WaveDrom (https://wavedrom.com/editor.html) output support to Silicon and Jupyter

-------------------
- Profile and speed-up elaboration (pyprof2calltree)
































------------------- OLD SCATTERED NOTES -------------------
Tests to add:
- Type-specifying input ports later on for all gates (that is binding through .-notation instead of all)
- Same as above, but with sub_ports: and.input_3[3] = ...
- Binding ports to abstract number types or ports with abstract number types
- Try to finalize port types after things are frozen. Maybe we should allow that? Maybe we should even encourage that, but automatically finalizing port types before freezing the port list???

In some ways, Junctions are just lazy-evaluation 'promises'. Or rather, their values are. This lazy evaluation can happen during simulation, or can be used to generate RTL. Maybe there's something there?


Alternatives:
    PyRTL - https://ucsbarchlab.github.io/PyRTL/
    pyverilog - https://pypi.org/project/pyverilog/ <-- actually, no, this is a Verilog parser and co. in Python.
    pyMTL - https://github.com/cornell-brg/pymtl
    myHDL - http://www.myhdl.org/

    All of them seem to take the road of trying to understand and convert python to RTL as opposed to 'describe' RTL in python.

