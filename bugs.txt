--------------------------------------------------------
FIXED

There is a problem with inline expression pass-through.

We determine whether a port is generated by an inline expression by filling in its 'rhs_expression'
property during evaluation of the module that exposes (as an output) that port.

Now, module evaluation is in the order of instentiation in the parent module, but that doesn't guarantee (apparently)
that every 'rhs_expression' is filled before its used. Here's an example:

    class top(cu.Module):
        out_a = cu.Output(cu.Signed(4))

        def body(self):
            self.out_a[1:0] = 0
            self.out_a[3:2] = 1

Here we generate a Concatenator *before* we generate the Constant object, because the Concatenator is generated
by the [] operator and the Constant is generated during binding.

Now, it could be special-cased by forcing (somehow) to insert the Constant before the Concatenator, but is this the
only case?

Normally you can only bind an output to an input if both the input and the output already exists.

The output can be auto-generated if there's a need for an adaption, such as the creation of a constant above.

Other then these cases though, the module whos output we're using exists already by the time the RHS is ready and '__set_attr__' is called.

Again, normally, at this point the LHS object already exists. So, the order of evaluation is going to be OK for these.

However, if *another* auto-generated module is needed to facilitate the assignment, *then* the order is wrong, potentially.

This is a problem for Concatenator for sure, probably for struct member accessors as well (those might need Concatenator-like things).

For interfaces, which allow member-wise assignment, such things are not necessary.

NOTE: explicit Concatenators should not suffer from this problem.

It seems that discovering and correcting this problem dynamically is a major headache, as by the time we realize this problem, we're deep
inside 'generate' for a particular sub-module and recursing into another generate is probably highly ill-advised.

Pre-generate detection of the issue is also very hard as the data-flow graph is not a DAG so there's no obviously 'incorrect' ordering.
This is also complicated by the fact that the second auto-generated Module (the Constant object in this case) must also be inlined for
the problem to repro.

So, I start to convince myself that the proper way of fixing this is to somehow swap the order of insertion into the parent.

Actually, fixing that was easy, but not a complete fix. In the same example above, the second Constant object gets created
*way* after the Concatenator was. In fact, this is a problem for most auto-created modules. Here's one more example:

        out_a = cu.Output(cu.Signed(5))
        in_a = cu.Input(cu.Signed(1))
        in_b = cu.Input(cu.Signed(1))

        def body(self):
            self.out_a[1:0] = 0
            self.out_a[3:2] = 1
            self.out_a[4] = self.in_a & self.in_b

Now, neither the second or the third assignment gets properly inlined. This seems to indicate that the problem really is with the module created for the LHS.

That was a fairly recent idea, used to unify the two kinds of concatenation that can happen in the language.

So, the real solution *must* be to re-order the eavluation order for *these* objects in the mail sub-module evaluation loop.

What needs to happen then, is that the evaluation order needs to be re-shuffled for *these* objects such that they are evaluated after
all their inputs.

Is that safe though?

The problem is that the Concatenator *cannot* be evaluated before its inputs but *has to* be evaluated before the first use of its output.

If there is a loop in there, that is the input is generated by a module that also consumes the output, we have issues.

*** Do we have a bigger problem though? ***

Afterall, Module creation order is completely arbitrary, using explicit module creation.

We need to detect this problem and do something about expression inlining in these cases...

The final solution (though maybe some cleanup is still needed) is this:
1. We don't create the Concatenator object right when the first slice is assgined.
2. Instead, we just record the fact that a slice-access was performed on the port and create a list of the slice-assignments inside the port object itself
3. After 'body' of the parent object executes, we iterate through all the ports and create the Concatenator objects as needed.
Now, this I still don't think is a panacea for all cases, at least as soon as we start relaxing RHS use of outputs, or IO ports. Consider this code:

        out_a = cu.Output(cu.Signed(5))
        out_b = cu.Output(cu.Signed(10))
        in_a = cu.Input(cu.Signed(1))
        in_b = cu.Input(cu.Signed(1))

        def body(self):
            self.out_b[4:0] = out_a
            self.out_b[9:5] = out_a
            self.out_a[1:0] = 0
            self.out_a[3:2] = 1
            self.out_a[4] = self.in_a & self.in_b
            
Here, we see a cases where the out_a-s Concatenator is created after out_b-s, yet out_b wants to pass through the value of out_a-s result. This case
was fixed in the previous checkin by forcing statement-inlining instead of expression inlining, so it's not broken.

Finally, I suspect that all sorts of funny cases can exist with explicit module instantiation where the generation order is completely independent
of the binding order. Again: the previous fix for forced statement-inlining handles those too, albeit in an uggly way.

----------------------------------------------------------
Need to create a Constant variant that can specify the length of the constant. Or some other means of being able to quicly write things like:

    self.out_a = concat(self.in_a, 3'b0, self.in_b)

----------------------------------------------------------
FIXED* (I think)

Need some way to allow variable slice assignment, along the lines of:
    c[0] = self.in_a & self.in_b
    c[1] = self.in_a | self.in_b
    self.out = c

----------------------------------------------------------
FIXED
Another problem with delayed type-determination. Consider the following code:

            self.uout3 = self.uin1 & self.uin2 | self.uin1 & self.uin3

Here, we create two AND gates, both of which uses delayed output type determination, so they simply have an untyped output port at the beginning.
Then, we attempt to create an OR gate, but how? Now, this OR gate has neither input ports typed. Right now __or__ and __ror__ both vector to the
port type, but that doesn't exist!

One solution would be that - since OR gates are type-agnostic anyways - to create the gate there at the port, but that limits type-based operator
overloading.

We could also use such a base functionality as a fall-back, *if* the type doesn't implement it, or there's no discenrable type. That would probably
result in a lot of confusion though.

----------------------------------------------------------
FIXED
Yet another problem with delayed type-determination. Consider the following code:

            self.uout10[0] = (self.uin1 & self.uin5)[2]

Here, we end up calling __getitem__ on the output port of the AND gate, which tries to vector to port_type's get_slice method. Well, of course there's
no such thing as port_type asserts.

Again, the solution is probably a generic fall-back implementation, something like a 'GetSlice' 'Module', which during late type-binding figures out
its innards. This however leads to another potential problem: when is GetSlice-s body called? This is good, actually: 'finalize_interface', which would
deal with this magic gets called before 'body' does.

----------------------------------------------------------
For speedup purposes, there seem to be JIT-ted Python variants, such as http://numba.pydata.org/.
They take a subset of Python so knowing which subset they take and stick to it would be a good idea

----------------------------------------------------------
There are delayed execution libraries, such as https://docs.dask.org/en/latest/
Since my modules are essentially delayed execution units and their ports are 'future promises',
these libraries might provide some interesting alternatives and ideas.

----------------------------------------------------------
Random old note:

PROBLEM: how to check that last-chance propagation converged? We'd need to re-check, but the change-set gets empty
before all inputs we set!

----------------------------------------------------------
FIXED* - except for generic inlining
Slices (that is self.b = a[3]) don't inline property.

The problem here is that the GetSlice module generates the Number.Accessor module inside it during late type-binding.

This Accessor is the one that gets properly inlined, but it gets inlined inside GetSlice.

It's not obvious to me how to leapfrog inlining all the way to the Accessor instance. Simply calling its generate_inline_expression
from that of GetSlice doesn't work because the bound ports are not 'inside', so the RHS name determination fails.

The generatred RTL is correct BTW, it's just butt ugly.

Solution: we should have a generic way of generating inlined bodies for these types of modules. By 'these types', I mean modules where all sub-module ports connect
to higher-level ports. That is to say, they don't have internal nodes. We should also make sure that every sub-module can be inlined. These restrictions are a bit
arbitrary, but with these, we should be able to fully inline the module. To actually facilitate that, we have two options:

1. Pass in a mapping of the names to be used for the sub-module ports.
2. Have thiss pass-through logic inside the ports themselves.

Either way, we somehow will have to inform the submodules that we perform this pass-through inlining. It's also an interesting question as to what should happen
with recursively inlined sub-modules.

--------------------------------------------------------------
FIXED
Reg needs global auto-clock and optional reset support.

Need to support:
- A global clock, if none is hooked up
- A reset input, that's dynamically created
- A reset value, that defaults to all 0-s, but can be specified as an optional input
- Support for sync and async resets through generic parameters for example.

---------------------------------------------------------------
Inline statements generate (potentially unnecessary) wire-definitions.

Inline statements use the corresponding output ports 'primary_name(False)' to get the name to represent their value.
This name always exists, but in many cases is just the auto-generated name because it immediately is assigned to another port.
In those cases, no named wire is necessary, we could optimize it out.

If the value is assigned to a local variable, a correct name is used and the generated RTL is actually valid, albeit a little
harder to read.

The solution is probably around the area where aliases are generated in the tracker: it could recognize the situation when
an output feeds a single other port and use the sinks name as an alias for the output. Then, 'generate' will have to be
careful and understand that no wire definition is needed to be generated for this name.

As the generated code is valid, I think it's low priority for now.

NOTE: Hopefully this is fixed with the XNet re-write

---------------------------------------------------------------
FIXED
Module creation order is screwed up.

There are two (simple) ways to create modules. One is using an expression, such as:
    self.x = (self.a & self.b) | self.c

In this case, an AND gate gets created followed by an OR gate. The order of gate creation
is determined by expression evaluation order.

The other way is:
    self.x = reg(self.a, rst_val = 0)

Here, first a REG module gets created and *during port binding*, which happens in __call__, a CONST module
gets created.

The problem is that the two orders are reverse from one another. Right now inlining happens in creation order,
so by the time the OR gate above gets inlined, its input AND gate has already been inlined and a rhs_expression
has been assigned to it.

However when REG gets inlined, CONST has not been interogated, so the code doesn't have access to a rhs_expression.
This results in awful RTL.

----------------------------------------------------------------
CLOSED - IRRELEVANT

I think this piece of code is incorrect (within module.py / generate()):

            # Generate assignments for all outputs and wires
            for port in chain(self.get_outputs().values(), self.get_wires().values()):
                source_str, _ = port.get_source_expression(back_end, self)
                first = True
                for name in port.get_all_names(True):
                    rtl_named_output_assignments += f"\tassign {name} = {source_str};\n"
                    if first:
                        source_str = name
                        first = False

    The problem here is that if an output (or a wire) is conneted to a sub-module, that is not inlined,
    we shouldn't generate the first line of 'assign' only the ones for the aliases.

NOTE: This piece of code is gone!!!

-----------------------------------------------------------------
This piece of code within netlist.py might be incorrect, when we get to interfaces: - FIXED

    def register_module(self, module: 'Module'):
        self.modules.add(module)
        for port in module.get_ports().values():
            self._register_port(port)

    This doesn't register 'wires' so interfaces can't use them. Maybe that's OK though.

------------------------------------------------------------------
Auto-Port binding with 'with': - this is more or less DONE

It would be nice, if one could specifcy the auto-bound ports using statements like this:

self.out1 = Reg(self.in1) # Binds to normal clock port
with self.clk2 as clk:
    self.out2 = Reg(self.in2) # Binds to clk2 as the clock port
with nested(self.clk2, self.reset2) as (clk, rst):
    ...

This should be doable as the 'with' statement introduces a new local variable into the
namespace. Trouble is, when 'bind_auto_ports' is called, this context is already gone.

So, what probably needs to happen is that 'Module' would need to save the callers' locals()
as a context and only release it after elaboration. This is complicated by the @NoTrace
intermedieries, which somehow would need to be skipped.

Doing so however might provide a good alternative for net name generation to Trace/NoTrace
directives: it's more contextual in the sense that locals introduced further down from
instantiation don't play a role.

------------------------------------------------------------------
Change this line:

        reg_c_bit = 1 << self.data_in[2:1]

to:

        reg_c_bit = 1 << self.data_in[3:1]

in i8255.py and watch the simulation fail with an 'assignment out-of-range' exception.
The exception is correct, but why isn't that a static error? The assignemnt ranges are
incorrect and that should be detectable!

--------------------------------------------------------------------
We should remove all the 'assignment is binding' crazyness. It only half works and is clunky.
Instead we should leave assignment as-is and support <<= for binding.

--------------------------------------------------------------------
FIXED

We really really need XNet support. (That is nets that cross the hierarchy)

The idea would be that names of these XNets are stored not on the ports, but in a central
location, keyed by the 'namespace' where the belong. There would be a list of names for
each namespace, the first being the primary.

This way the naming shananigans can be greatly simplified and all this 'inner alias'
'outer alias', 'primary name' 'auto_name' crazyness would go away.

Alas, it more or less works for now, so I'm not going to blow things up immediately.

--------------------------------------------------------------------
FIXED, I THINK

Array of wires don't get names, apparently.

This example (from gate_array.py):
        self.pen_colors = []
        for i in range(17):
            self.pen_colors.append(Wire(Unsigned(length=5)))
        for i in range(17):
            self.pen_colors[i] <<= Reg(Select(reg_wr & color_select & self.pen_sel_reg == i, self.pen_colors[i], self.data_in[4:0]))

Can't generate RTL, because (apparently) self.pen_color[i] doesn't have any names, so it can't be
used in an inline expression.

It probably doesn't have a name, because it wasn't caught by anybody and moved out from _local_wires into _wires.
Parent module is set, and it IS in _local_wires though, so that's a start...
--------------------------------------------------------------------
Select with None as one of the inputs can't determine output type - FIXED
--------------------------------------------------------------------
test_primitives - test_reg: - FIXED

The second domain creates a second 'clk' wire, which gets renamed to clk_1.
All is fine, except this is totally unnecessary and makes for a somewhat
uglier RTL.
--------------------------------------------------------------------
For some reason killing isinstance calls for determing if something is a port doesn't quite work.
For now, I've replaced them with a special function in .utils, but they still depend on isinstance.
I think this has to do with object creation and the fact that duck-typing depends on a fully constructed object (maybe)?

--------------------------------------------------------------------
tracer should not use inner/outer aliases but create wire objects for the aliases as necessary: FIXED

--------------------------------------------------------------------
We should try to make function calls within a 'body' to be as close to a sub-module as possible.
In fact, if simple functions could be modules, that would be ideal.
Either way, the tracer trying to recurse into function calls is rather obnoxious. The default should probably be no_trace and
have an attribute (something like @module) on functions that we do want to make sub-modules of.

--------------------------------------------------------------------
with my_port as clk: FIXED
    xxxx

This construct needs to make sure that 'clk' disappears from locals after __exit__.
First, I'll have to see if it does (it most likely doesn't) and if I'm right, this needs fixing.
The way to fix it probably is to capture all the aliases for my_port in __enter__ and restore them
in __exit__. Not ideal, as the with-block might introduce new aliases to my_port which would also
get wiped away at __exit__, but close enough.

Well, that doesn't seem to work: manipulation of the 'locals' of the callers' stack is not possible
apparently because locals() (and co.) returns a *copy* of the dict, not the dict itself.

So, the next way of doing this, is __enter__ to return some kind of reference object that __exit__
will invalidate. That way, the local variable (clk in this case) remains in scope, but the
auto-binding rules will fail due to the invalidation. Bleh...

BTW: normal binding process probably should be inhibited as well?

BTW2: what if 'clk' already had a value before __enter__? That value should be saved up in whatever
temp object is returned so it could be restored upon __exit__.

Well, fixed it as much as I could: __exit__ invalidates the context, but can't override
the binding of the local. So, at least further auto-binds to that local are prohibited,
but still not the best experience. This could potentially be improved in the following way:

__enter__ returns an 'AutoPort' object. This object gets bound to the local. It also remembers
the object it returned.
__exit__ re-binds this AutoPort to the original object that was bound to the local, or simply
sets it not auto-boundable if the local didn't exist at the time of __enter__ - which BTW
is a tricky thing to determine.

Now it's fixed I think to the best of what's possible. If the scoped port gets assigned
to multiple local variables that already held a value outside the with scope, then we
fail to re-jiggle the references in __exit__, but should (untested) raise an exception
about it. There's really not much that could be done about it, so this is the best it'll get.
It's such a corner-case that it should be OK, I think.

----------------------------------------------
FIXED

<<= assignment to slices doesn't work:

self.out_a[0] <<= my_wire

The problem is that this is a read-modify-write by the original meaning. So, first, the RHS expression for
self.out_a[0] is accessed, which is generating a slice module, returning it's output. Then, we try to use *that*
output as the LHS of the subsequent assignment, which of course fails.

This is a more relevant case where the [] operator doesn't really know immediately whether it is on the LHS or the RHS,
so it should return some temp object that can be used in either context.

Here's another example:
    This type of assignment is not supported:

            r12_r13_start_addr[13:8] <<= Reg(Select(wr_reg & reg_idx == 0, r12_r13_start_addr, self.data_in[5:0]))

    The problem (I think) is that since the left-side is not of a self.<<member>> form, it
    doesn't use __getattr__ so it is not recognized as a LHS expression.
    Actually, it doesn't work even with this:

            self.r12_r13_start_addr[13:8] <<= Reg(Select(wr_reg & reg_idx == 0, self.r12_r13_start_addr, self.data_in[5:0]))

The repro is in test_basics.py test_slice_bind()

-----------------------------------------------
We don't scan names for reserved names within a back-end. For example, test_basics.py test_wire_array() uses 'bit' as a variable.
That's perfectly fine in python, but not in SV.
-----------------------------------------------
FIXED
test_module_decorator: the input/output types for the generated RTL are CLEARLY wrong. They are mostly missing the vector specification.

-----------------------------------------------
With current slice implementation, this doesn't really raise an error. Maybe it should:

def test_slice_new():
    class top(Module):
        uout2 = Output(Unsigned(length=2))
        uin1 = Input(Unsigned(length=2))

        def body(self):
            x = self.uout2[0]
            x <<= self.uin1[0]

    test.rtl_generation(top, inspect.currentframe().f_code.co_name)

The problem is that for this to work:
    self.uout2[0] <<= 1

we'll have to implement <<= on the Output.OutputPortSlice object. This automatically allows the first form to compile, so I'm not sure of this is fixable.
------------------------------------------------
For some reason size-adapters generate extra wire names even though they get inlined properly.
Most likely reason is that the inlined version is just a port name, so maybe we confuse it to a RHS expression?
-----------------------------------------------
Multiple cascaded [] accessors within a simulation context don't work.

So, while:
    a <<= b[4:0][2]
synthesizes, if appears in 'body', it doesn't simulate if it appears in 'simulate'.
Note: these two code-paths are very different and I'm just too lazy to make the simulation path working.
Of course, if it appears within a 'body', it will simulate just fine. The problem is that no modules and
accessors are created for the same construct within 'simulate'.
------------------------------------------------
FIXED, sort of: actually this cannot be removed, but added a bunch of comments to explain why.
It essemtially boils down to implicit type-conversions during output type determination and
type propagation.

I think the handling of _unordered_sub_modules is more complicated than it should be:
The only time we should be instantiating sub_modules out of the normal body process is
when we create the concatenators at the end of processing of a module. This loop however
hapens right after we empty out _unordered_sub_modules. So if we simply reversed the two
loops, things should fall in order and all sub_module creation should happen while
_unordered_sub_modules is still alive. This would also allow the removal of the None-checkes
for _unordered_sub_modules.
------------------------------------------------
FIXED, I think.

Decide whether it's = or <<= that does the actual binding. I think it should always be <<=,
but im MemberAccess it simply returns 'other' and thus delegating the binding to the
following __setattr__/__setitem__. I *think* in this particular context this will always
happen unless we manage to create a stand-alone MemberAccess instance somehow
------------------------------------------------
One can generate strange RTL, with this trick:

    def test_local_slice():

        class Top(Module):
            out_a = Output(Unsigned(5))
            in_c = Input(logic)

            def body(self):
                x = self.out_a[3:0]
                x <<= self.in_c
                self.out_a[4] = 1

        test.rtl_generation(Top, inspect.currentframe().f_code.co_name)

This generates:

    ////////////////////////////////////////////////////////////////////////////////
    // Top
    ////////////////////////////////////////////////////////////////////////////////
    module Top (
        output logic [4:0] out_a,
        input logic in_c
    );

        logic [3:0] x;

        assign x = out_a[3:0];
        assign out_a = {1'h1, 4'(in_c)};

    endmodule

The problem here is that x really is a reference to a section of the output, something that *should be* illegal,
but can't be made so within Python. This reference gets registered as a wire and then RTL is generated for it,
which then reads a value of an output.

Now, as luck would have it, this is actually valid Verilog, but would not be valid VHDL.
------------------------------------------------
A strange side-effect of the current construction is that interface-signals
can be assigned to one another within one interface.
I'm not sure we should allow that...

Repro is in test_interface.py:test_composite_interface4
------------------------------------------------
At the moment gate_array doesn't compile. It complains (legitimately) about a type error here:

        # pen register
        self.pen_sel_reg = Wire(Number(min_val = 0, max_val = 16)) # 0...15: pen, 16: border
        self.pen_sel_reg <<= Reg(Select(reg_wr & pen_select, self.pen_sel_reg, self.data_in[4:0] & pen_mask))

The complaint is that the input to select is a 5-bit value, yet the output is assigned to a range 0...16.
That is all true. We *know* however that the pen value cannot go beyond 16. It's just not communicated to Silicon.
We would need a type-cast here, but it doesn't exist yet (we can only do type-casts with the [] operator, but that's
insufficient in this instance).

This BTW will come up pretty soon in memories, where we'll have to go between structs and numbers.
